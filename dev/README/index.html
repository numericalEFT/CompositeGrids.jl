<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · CompositeGrids.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://numericaleft.github.io/CompositeGrids.jl/README/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>CompositeGrids.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#Installation"><span>Installation</span></a></li><li class="toplevel"><a class="tocitem" href="#Quick-Start"><span>Quick Start</span></a></li><li class="toplevel"><a class="tocitem" href="#Manual"><span>Manual</span></a></li><li><a class="tocitem" href="#Basics"><span>Basics</span></a></li><li><a class="tocitem" href="#Simple-Grids"><span>Simple Grids</span></a></li><li><a class="tocitem" href="#Composite-Grids"><span>Composite Grids</span></a></li><li><a class="tocitem" href="#Interpolation-and-Integration"><span>Interpolation and Integration</span></a></li><li><a class="tocitem" href="#Complexity-of-Operations"><span>Complexity of Operations</span></a></li></ul></li><li><a class="tocitem" href="../">API reference</a></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../lib/simple/">Basic Grids</a></li><li><a class="tocitem" href="../lib/composite/">Composite Grids</a></li><li><a class="tocitem" href="../lib/interpolate/">Interpolation and Integration</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/numericalEFT/CompositeGrids.jl/blob/master/docs/src/README.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><p><a href="https://numericaleft.github.io/CompositeGrids.jl/dev/"><img src="https://img.shields.io/badge/docs-dev-blue.svg" alt="img"/></a> <a href="https://github.com/numericaleft/CompositeGrids.jl/actions"><img src="https://github.com/numericaleft/CompositeGrids.jl/workflows/CI/badge.svg" alt="img"/></a> <a href="https://codecov.io/gh/numericaleft/CompositeGrids.jl"><img src="https://codecov.io/gh/numericalEFT/CompositeGrids.jl/branch/master/graph/badge.svg?token=WN6HO1XASY" alt="img"/></a></p><h1 id="Introduction"><a class="docs-heading-anchor" href="#Introduction">Introduction</a><a id="Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction" title="Permalink"></a></h1><p><span>$CompositeGrids.jl$</span> is a powerful Julia package that provides a unified interface for generating a wide range of common 1D grids. In addition to basic grids, this package allows you to create composite grids by combining multiple fundamental grids. These composite grids are enriched with essential functionalities, including floor function, interpolation function, and integration function, all of which are optimized to enhance their performance on specific grids.</p><p>With <span>$CompositeGrids.jl$</span>, you can effortlessly construct complex grids and efficiently handle various numerical tasks with ease. Whether you are working on scientific simulations, data analysis, or any other domain that involves grid-based calculations, this package will be your go-to tool for managing grids effectively.</p><h1 id="Installation"><a class="docs-heading-anchor" href="#Installation">Installation</a><a id="Installation-1"></a><a class="docs-heading-anchor-permalink" href="#Installation" title="Permalink"></a></h1><p>To install <span>$CompositeGrids.jl$</span>, use Julia&#39;s package manager. Open the Julia REPL, type <code>]</code> to enter the package mode, and then:</p><pre><code class="nohighlight hljs">pkg&gt; add CompositeGrids.jl</code></pre><h1 id="Quick-Start"><a class="docs-heading-anchor" href="#Quick-Start">Quick Start</a><a id="Quick-Start-1"></a><a class="docs-heading-anchor-permalink" href="#Quick-Start" title="Permalink"></a></h1><p>In this quick start example, we will demonstrate how to generate a grid from 0 to 1, log-densed at 0 and 1, and optimized for integration using the <span>$CompositeGrids.jl$</span> package. We will provide descriptive comments in the code to guide you through the process.</p><pre><code class="language-julia hljs">    using CompositeGrids
    
    # Generating a log densed composite grid with LogDensedGrid()
    tgrid = CompositeGrid.LogDensedGrid(
        type=:gauss,# The top layer grid is :gauss, optimized for integration. For interpolation use :cheb
        bound=[0.0, 1],# The grid is defined on [0.0, β]
        dense_at=[0.0, 1],# and is densed at 0.0 and β, as given by 2nd and 3rd parameter.
        N=5,# N of log grid
        minterval=0.005, # minimum interval length of log grid
        order=5 # N of bottom layer
    )
    # The grid has 3 layers.
    # The top layer is defined by the boundary and densed points. In this case its:
    println(&quot;Top layer:&quot;,tgrid.panel.grid)
    # The middle layer is a log grid with 4 points and minimum interval length 0.001:
    println(&quot;First subgrid of middle layer:&quot;,tgrid.subgrids[1].panel.grid)
    # The bottom layer is a Gauss-Legendre grid with 5 points:
    println(&quot;First subgrid of bottom layer:&quot;,tgrid.subgrids[1].subgrids[1].grid)
    
    # function to be integrated:
    f(t) = exp(t)+exp(1-t)
    # numerical value on grid points:
    data = [f(t) for (ti, t) in enumerate(tgrid.grid)]
    
    # integrate with integrate1D():
    int_result = Interp.integrate1D(data, tgrid)
    
    println(&quot;result=&quot;,int_result)
    println(&quot;comparing to:&quot;,2*(exp(1)-1))</code></pre><pre><code class="nohighlight hljs">Top layer:[0.0, 0.5, 1.0]
First subgrid of middle layer:[0.0, 0.005000000000000001, 0.023207944168063897, 0.1077217345015942, 0.5]
First subgrid of bottom layer:[0.00023455038515334025, 0.0011538267247357924, 0.0025000000000000005, 0.0038461732752642086, 0.004765449614846661]
result=3.43656365691809
comparing to:3.43656365691809</code></pre><h1 id="Manual"><a class="docs-heading-anchor" href="#Manual">Manual</a><a id="Manual-1"></a><a class="docs-heading-anchor-permalink" href="#Manual" title="Permalink"></a></h1><h2 id="Basics"><a class="docs-heading-anchor" href="#Basics">Basics</a><a id="Basics-1"></a><a class="docs-heading-anchor-permalink" href="#Basics" title="Permalink"></a></h2><p>The <span>$CompositeGrids.jl$</span> package offers two modules for working with 1D grids: <span>$SimpleGrid$</span> and <span>$CompositeGrid$</span>. These modules provide a collection of common 1D grids with straightforward definitions and simple structures. Additionally, <span>$CompositeGrid$</span> defines a more general type of grid, composed of a panel grid and a set of subgrids, allowing for more flexibility in grid construction.</p><p>The common interface for grids includes the following properties and methods:</p><ul><li><p><span>$g.bound$</span>: This property gives the boundary of the interval of the grid. It provides a clear indication of the range covered by the grid.</p></li><li><p><span>$g.size$</span>: This property gives the total number of grid points in the grid. It helps to determine the grid&#39;s resolution and granularity.</p></li><li><p><span>$g.grid$</span>: This property gives an array of grid points. The array contains the coordinates of all the grid points within the specified boundary.</p></li><li><p><span>$g[i]$</span>: This method returns the i-th grid point, which is the same as <span>$g.grid[i]$</span>. It allows for direct access to specific grid points.</p></li><li><p><span>$floor(g, x)$</span>: This method returns the largest index of the grid point where <span>$g[i] &lt; x$</span>. For values of x below the first grid point, it returns 1, and for values greater than the last grid point, it returns <span>$(grid.size - 1)$</span>. This ensures that both <span>$floor()$</span> and <span>$(floor() + 1)$</span> are valid grid indices for any value of x.</p></li></ul><p>The <span>$CompositeGrids.jl$</span> package also provides interpolation and integration functionalities for the grids. Different implementations are available for different types of grids, allowing for efficient numerical calculations tailored to each grid type.</p><h2 id="Simple-Grids"><a class="docs-heading-anchor" href="#Simple-Grids">Simple Grids</a><a id="Simple-Grids-1"></a><a class="docs-heading-anchor-permalink" href="#Simple-Grids" title="Permalink"></a></h2><p>The <code>SimpleGrid</code> module in <code>CompositeGrids.jl</code> offers various basic grids that serve as standalone grids and components of composite grids. The available basic grids include:</p><ul><li><p><strong>Arbitrary Grid:</strong> The most general basic grid, which takes an array and converts it into a grid. It provides an efficient O(ln(N)) floor function based on <code>searchsortedfirst()</code>.</p></li><li><p><strong>Uniform Grid:</strong> Defined by the boundary and the number of grid points. It offers an O(1) floor function for rapid point location.</p></li><li><p><strong>Log Grid:</strong> Defined by the boundary, number of grid points, minimum interval, and direction. It generates a log-dense grid based on the provided parameters. An O(1) floor function is provided. For example:</p></li></ul><pre><code class="language-julia hljs">    using CompositeGrids
    loggrid = SimpleGrid.Log{Float64}(
        bound=[0.0,1.0], N=6, 
        minterval=0.0001, 
        d2s = true) # dense to sparse
    println(loggrid.grid)</code></pre><pre><code class="nohighlight hljs">    [0.0, 0.00010000000000000005, 0.0010000000000000002, 0.010000000000000002, 0.1, 1.0]</code></pre><ul><li><p><strong>BaryCheb Grid:</strong> Specifically designed for interpolation, it is defined by the boundary and number of grid points. The grid points are distributed according to Chebyshev nodes. The floor function is not optimized, so the O(ln(N)) function will be used, but the interpolation is based on an high precision algorithm with O(N).</p></li><li><p><strong>GaussLegendre Grid:</strong> Tailored for integration purposes, it is defined by the boundary and number of grid points. The grid points are distributed according to Gauss-Legendre quadrature. The floor function is not optimized, so the O(ln(N)) function will be used. The 1D integration is optimized.</p></li></ul><p>It&#39;s important to note that grids can be categorized into open grids and closed grids. Closed grids indicate that the boundary points are also included as grid points, while open grids exclude the boundary points. The <span>$BaryCheb$</span> and <code>GaussLegendre</code> grids are examples of open grids.</p><p>A detailed manual can be found <a href="https://numericaleft.github.io/CompositeGrids.jl/dev/lib/simple/">here</a>.</p><h2 id="Composite-Grids"><a class="docs-heading-anchor" href="#Composite-Grids">Composite Grids</a><a id="Composite-Grids-1"></a><a class="docs-heading-anchor-permalink" href="#Composite-Grids" title="Permalink"></a></h2><p>The <code>CompositeGrid</code> module in <code>CompositeGrids.jl</code> provides a general type of grid where the entire interval is first divided by a panel grid, and then each interval of the panel grid is further divided by smaller grids called subgrids. Notably, subgrids can also be composite grids themselves, allowing for hierarchical grid structures.</p><p>The <code>LogDensedGrid</code> is a particularly useful generator of composite grids that offers a general solution when a log-dense 1D grid is needed around specific points within an interval. For example, grids like &amp;tau; grids, which require densification around 0 and &amp;beta;, or momentum grids, which need densification around the Fermi momentum, can be efficiently generated using <code>LogDensedGrid</code>.</p><p>The <code>LogDensedGrid</code> is defined as a three-layer composite grid:</p><ol><li><p><strong>Top Layer (Arbitrary Grid):</strong> This layer is defined by the boundary and the points where the grid needs to be dense. It allows for high flexibility in defining the grid structure.</p></li><li><p><strong>Middle Layer (Log Grid):</strong> This layer is log-dense at the specified points, ensuring finer resolution in regions of interest.</p></li><li><p><strong>Bottom Layer (Grid of Options):</strong> The bottom layer can be one of three options: <code>:cheb</code> for BaryCheb grid used for interpolation, <code>:gauss</code> for GaussLegendre grid used for integration, and <code>:uniform</code> for a uniform grid that serves general purposes.</p></li></ol><p>The floor function of the composite grid is defined recursively. When locating a grid point, the floor function of the panel grid is called first to find the corresponding subgrid, and then the floor function of the subgrid is called to determine the final result. Since subgrids can themselves be composite grids, this recursive process continues until the lowest level of subgrids is reached.</p><p>The hierarchical nature of composite grids allows for the creation of sophisticated grid structures tailored to specific needs, making them a powerful tool for various scientific and computational applications.</p><p>A detailed manual can be found <a href="https://numericaleft.github.io/CompositeGrids.jl/dev/lib/composite/">here</a>.</p><h2 id="Interpolation-and-Integration"><a class="docs-heading-anchor" href="#Interpolation-and-Integration">Interpolation and Integration</a><a id="Interpolation-and-Integration-1"></a><a class="docs-heading-anchor-permalink" href="#Interpolation-and-Integration" title="Permalink"></a></h2><h3 id="Interpolation"><a class="docs-heading-anchor" href="#Interpolation">Interpolation</a><a id="Interpolation-1"></a><a class="docs-heading-anchor-permalink" href="#Interpolation" title="Permalink"></a></h3><p>Interpolation in <code>CompositeGrids.jl</code> provides an estimate of the function value at a given point <code>x</code> using the provided grid and function values on the grid points. For most of the simple grids, linear interpolation is used in conjunction with the floor function to locate the corresponding grid points. Notably, the BaryCheb grid employs an optimized algorithm for interpolation, leveraging information from all grid points to yield more precise results with the same number of grid points. This enhanced interpolation is subject to the condition that the function itself is smooth enough. When working with composite grids, the interpolation process is performed recursively, and the final result depends on the type of the lowest-level grid. For higher dimensions where data is defined on a list of grids, linear interpolation is provided, even when some of the grids are of the BaryCheb type.</p><h3 id="Integration"><a class="docs-heading-anchor" href="#Integration">Integration</a><a id="Integration-1"></a><a class="docs-heading-anchor-permalink" href="#Integration" title="Permalink"></a></h3><p>Integration over 1D grids is supported in <code>CompositeGrids.jl</code>. For most of the simple grids, linear integration is employed. However, for <span>$GaussLegendre$</span> grids and <span>$BaryCheb$</span> grids, an optimized integration method is used. Similar to interpolation, integration for composite grids is also carried out recursively, and the chosen method depends on the type of the lowest-level grids.</p><h3 id="Differentiation"><a class="docs-heading-anchor" href="#Differentiation">Differentiation</a><a id="Differentiation-1"></a><a class="docs-heading-anchor-permalink" href="#Differentiation" title="Permalink"></a></h3><p>The <code>CompositeGrids.jl</code> package offers differentiation for 1D grids. Specifically, a high-precision algorithm is implemented for <span>$BaryCheb$</span> grids, resulting in accurate differentiation results.</p><p>A detailed manual can be found <a href="https://numericaleft.github.io/CompositeGrids.jl/dev/lib/interpolate/">here</a>.</p><p>An example of interpolation and differenciation is shown below:</p><pre><code class="language-julia hljs">using CompositeGrids
β = π

# Generating a log densed composite grid with LogDensedGrid()
tgrid = CompositeGrid.LogDensedGrid(
    type=:cheb,# The top layer grid is :cheb
    bound=[0.0, β],# The grid is defined on [0.0, β]
    dense_at=[0.0, β],# and is densed at 0.0 and β, as given by 2nd and 3rd parameter.
    N=5,# N of log grid
    minterval=0.005, # minimum interval length of log grid
    order=5 # N of bottom layer
)

# function to be represented:
f(t) = sin(t)
# numerical value on grid points:
data = [f(t) for t in tgrid]

# integrate with integrate1D():
sin1 = Interp.interp1D(data, tgrid, 1.0)
dsin1 = Interp.differentiate1D(data, tgrid, 1.0)

println(&quot;result=&quot;, (sin1, dsin1))
println(&quot;comparing to:&quot;, (sin(1.0), cos(1.0)))</code></pre><pre><code class="nohighlight hljs">result=(0.8414425112056995, 0.5400742649805592)
comparing to:(0.8414709848078965, 0.5403023058681398)</code></pre><h2 id="Complexity-of-Operations"><a class="docs-heading-anchor" href="#Complexity-of-Operations">Complexity of Operations</a><a id="Complexity-of-Operations-1"></a><a class="docs-heading-anchor-permalink" href="#Complexity-of-Operations" title="Permalink"></a></h2><table><tr><th style="text-align: right">Grid\Operation</th><th style="text-align: right">Floor</th><th style="text-align: right">Interpolate</th><th style="text-align: right">Integrate</th><th style="text-align: right">Differentiate</th></tr><tr><td style="text-align: right">Arbitrary</td><td style="text-align: right">O(ln(N))</td><td style="text-align: right">O(ln(N))</td><td style="text-align: right">O(N)</td><td style="text-align: right">O(ln(N))</td></tr><tr><td style="text-align: right">Uniform</td><td style="text-align: right">O(1)</td><td style="text-align: right">O(1)</td><td style="text-align: right">O(N)</td><td style="text-align: right">O(1)</td></tr><tr><td style="text-align: right">Log</td><td style="text-align: right">O(1)</td><td style="text-align: right">O(1)</td><td style="text-align: right">O(N)</td><td style="text-align: right">O(1)</td></tr><tr><td style="text-align: right">BaryCheb</td><td style="text-align: right">O(ln(N))</td><td style="text-align: right">O(N)</td><td style="text-align: right">O(N)</td><td style="text-align: right">O(N)</td></tr><tr><td style="text-align: right">GaussLegendre</td><td style="text-align: right">O(ln(N))</td><td style="text-align: right">O(ln(N))</td><td style="text-align: right">O(N)</td><td style="text-align: right">O(ln(N))</td></tr><tr><td style="text-align: right">CompositeGrid</td><td style="text-align: right">O(floor(panel)*floor(sub))</td><td style="text-align: right">O(floor(panel)*interp(sub))</td><td style="text-align: right">O(N)</td><td style="text-align: right">O(floor(panel)*diff(sub))</td></tr></table><p><strong>Note 1</strong>: For <code>CompositeGrid</code>, the complexity depends on the type of the low-level grid in the hierarchy.</p><p><strong>Note 2</strong>: Interpolation and differentiation of <span>$BaryCheb$</span> are implemented with high-precision algorithm, thus much less grid points are needed despite complexity.</p></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="../">API reference »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Wednesday 26 July 2023 19:58">Wednesday 26 July 2023</span>. Using Julia version 1.9.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
